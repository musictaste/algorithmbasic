[TOC]

# 归并排序

1.整体是递归，左边排好序+右边排好序+merge让整体有序

2.让其整体有序的过程中用了排外序方法

3.利用master公式来求解时间复杂度

4.当然可以用非递归实现

## 归并排序的过程
    
    f(arr,L,R)函数：让数组arr的L到R的位置变有序
    
    分成两部分，左部分、右部分；调用f(L,M)、f(M+1,R)函数让左右两部分分别有序
    
    接下来让整个数组有序
    
    先申请一个跟数据大小一样的辅助数组other
    
    左右两部分分别有一个指针，左右两部分指针对应的数字进行比较，谁的数字小，就把该数字放入数组other中；然后指针后移；
    
    当指针所在的位置数字相等，则默认先放入左部分的数字，再放入右部分的数字
    
    当指针不在某一个部分范围内后，将另一部分的剩余的数字放入数组other中国
    
    最后再将other数组刷到原先的数组中，从而实现归并排序
 
## 归并排序-非递归的实现

首先k=2，相邻两个数字进行merge()；最后如果只剩一个数字，则不管

接下来k=4,四个数字进行merge();不够4个数字的作为一组进行merge（）

接下来k=8,k=16,直到k >= 数组的长度



```
Code01
```

## 递归实现的时间复杂度:O(NlogN)

merge的时间复杂度：O(N)

master公式：T(N)=2*T(N/2) +O(N)

a=2  b=2  d=1

loga^b=d  O(N*logN)

==O(NlogN)==


## 非递归实现的时间复杂度:O(NlogN)

    Merge=1   O(N)
    Merge=2   O(N)
    Merge=4   O(N)
    Merge=8   O(N)
    
    log2^N次  * O(N) = O(N*logN)

## 小结

第一节课程：选择排序、冒泡排序、插入排序的时间复杂度O(N²)

本质上选择、冒泡、插入都是大量浪费比较行为，导致的N²出现的

归并排序，没有浪费比较行为；每一次比较的行为都留下来，作为下一次比较的基础


## 用常见面试题再深入理解一下归并排序的精髓

在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和

    例子：[1,3,4,2,5]
    1左边比1小的数：没有
    3左边比3小的数：1
    4左边比4小的数：1、3
    2左边比2小的数：1
    5左边比5小的数：1、3、4、2
    所以数组的小和为1+1+3+1+1+3+4+2=16

第一种方案：暴力遍历，时间复杂度O(N^2)

第二种方案：利用归并排序，

    只有当左组的数小于右组的数时，才产生小和
    当左组的数等于右组的数，拷贝右组的数，不产生小和
    当左组的数大于右组的数，拷贝右组的数，不产生小和
    
    分为两组：1、3       4、2、5
    
    左组【1,3】产生小和：1     数组拷贝：1,3
    右组【4,2，5】再分为两组：【4】  【 2，5】
        左组【4】没有对应的右组，直接写回
        小组【2,5】产生小和2     数组拷贝：2,5
    
        小组【4,2,5】产生小和4， 数组拷贝：2，4，5
    
    小组【1,3，2,4,5】
        左组1，比较右组【2,4,5】，得到小和：3个1
        左组3，比较右组【2,4,5】，得到小和：2个3
        
        数组拷贝：1，2,3,4,5
    
    数组小和：1 + 2 + 4 +1+1+1 + 3+3=16
    
注意：每次merge才会产生小和；

所有merge产生的小和，累计起来就是数组小和

第三种思路：遍历数组，当前数字右边的数字比它大，则产生小和

    【1,3,4,2,5】
    1右边比它的数有4个，产生小和：4个1
    3右边比它的数有2个，产生小和：2个3
    4右边比它的数有1个，产生小和：1个4
    2右边比它的数有1个，产生小和：1个2
    5右边比它的数有0个，没有小和
    

```
code02

```

## 在一个数组中，求所有的降序对（求数组中右边有多少个数比它小）

一个数组：【3,1，7,0,2】

    降序对：
    遍历3：（3,1） （3,0）（3,2）
    遍历1：(1,0)
    遍历7：(7.0) (7,2)
    遍历0 
    遍历2：
    
实际就是求当前数   右边的数有多少个比它小


## 什么问题可以用归并排序

适用于：

右边有多少个数比它大

或右边有多少个数比它小

或左边有多少个数比它大

或左边有多少个数比它小

最后求这些所有的数


## 求数组中左边有多少个数比它大

如果左边和右边相等时，==先拷贝左边的数==；然后得到左边比它大的数的个数

# 快速排序

## Partition过程

给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。

要求额外空间复杂度O(1),时间复杂度O(N)

思路分析：
    先有一个 小于等于区，下标为-1
    1）当前数 <= num: 当前数 和 小于等于区的下一个位置 进行交换；小于等于右移；i++
    2).当前数 > num ;i++
    
    
    例如有一个数组【5,3,7,2,3,4,1】，num=3
    5：i++
    3:  3和5进行交换，【3,5,7,2,3,4,1】;  小于等于区下标为0
    7：i++
    2：2和5交换  【3,2,7,5,3,4,1】小于等于区下标为1
    3：3和7交换  【3,2,3,5,7,4,1】小于等于区下标为2
    4：i++
    1：1和5交换  【3,2,3,1,7,4,5】小于等于区下标为3
    

```
Code03_PartitionAndQuickSort
```

## 扩展：荷兰国旗问题的划分：数组arr，一个整数num，分成三个区：小于在左边，大于在右边，


    小于区：下标-1
    大于区：下标n
    1)[i] ==num: i++
    2)[i] < num: [i]与小于区右一个数字进行交换，小于区右扩(下标+1)；i++
    3)[i] >num: [i]与大于区左一个数字进行狡猾，大于区左扩(下标-1);i不变；

    例如有一个数组【3,5,4,0,4,6,7,2】，num=4
    小于区：下标-1
    大于区：下标8
    
    3：3和自己交换，小于区下标为0  【3,5,4,0,4,6,7,2】 i++
    5：5和2交换，大于区下标为7  【3,2,4,0,4,6,7,5】 
    2：2和自己交换，小于区下标1   【3,2,4,0,4,6,7,5】 i++
    4：i++
    0：0和4交换，小于区下标2   【3,2,0,4,4,6,7,5】  i++
    4：i++
    6：6和7交换， 大于区下标为6 【3,2,0,4,4,7,6,5】
    7：7和自己交换，大于区下标为5    i=5 = 大于区下标
```
Code03_PartitionAndQuickSort
```

## 快速排序1.0版本

利用Partition，拿出最后一个数作为R，得到【[<=x] x [>x]   】

<=x的区域再进行递归Partition

>x的区域也进行递归Partition


## 快速排序2.0版本

相比1.0版本，搞定了和R相等的一批数

【 [<x] ==x [>x]  】

## 快速排序3.0版本（随机快排）

最坏情况[1,2,3,4,5,6,7,8]

如果采用1.0版本、2.0版本；时间复杂度是O(N^2)

快速排序3.0版本的时间复杂度O(NlogN)

快速排序3.0版本：随机选一个数，然后再进行Partition的操作

## 随机快排的时间复杂度分析

最优情况是：随机选的这个数，正好在中间位置；左边和右边做递归

Partition的时间复杂度是O(N)

T(N)= 2*T(N/2) + O(N) 

利用Master公式，a=2,b=2,d=1 得到O(NlogN)

-----

因为是随机取一个数，那么造成的时间复杂度公式有可能是

T(N)= O(N2)

T(N)= 2*T(N/2) + O(N) 

T(N)= T(N/3) +T(2N/3) + O(N)  这种情况不能使用Master公式进行计算

T(N= T(3N/7) + T(4N/7) +O(N)   这种情况不能使用Master公式进行计算

因为上面每一种情况的概率是1/N，

==数学家求了概率累加，长期的期望是=O(N*logN)==

---------

1.通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差

2.随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件

3.把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N

4.那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！

时间复杂度O(N*logN),额外时间复杂度O(logN)都是这么来的


好情况的空间复杂度O(logN) 

最差情况的空间复杂度O(N)

概率累加以后长期期望O(logN)

-----

这门课只讲 选择、冒泡、插入、归并、快排、堆排等8种

希尔排序是基于插入排序来的

其他排序的地位比较低，所以不重要