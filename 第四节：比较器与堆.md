# 堆

## 定义

1.堆结构就是用数组实现的完全二叉树结构
2.完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3.完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4.堆结构的heapInsert与heapify操作
5.堆结构的增大和减少
6.优先级队列结构，就是堆结构


完全二叉树：除了最后一层，其他层都有左右子节点，并且保证最后一个节点之前的节点都齐全

节点i

i的左节点=2*i+1

i的右节点=2*i+2

i的父节点=i-1/2

----
还有一种特殊的二叉树==：0的位置不使用，头节点从1开始==

==这种二叉树可以使用位运算，运算速度快==

节点i

i的左节点：i*2 ( i<<1 )

i的右节点：i*2+1 ( i<<1 | 1 )

i的父节点：i/2 ( i>>1 )

## heapInsert：把所有数字组织成大根堆的的形式

现在有一个数组，有一个初始长度，数组长度够用，用户没有提供数字之前，我认为数组中的所有位置都是无效区；现在提供数字，请你把所有数字组织成大根堆的的形式


如果二叉树的节点个数为N，那么树的节点高度为logN

那么如果如果新加入一个节点，完全二叉树的节点个数为N，那么把这个完全二叉树调整为大根堆的代价是每一步都是logN

## heapify：现在呢，用户想要得到这个大根堆的最大值，并把它删除，再调整为最大堆

1.把下标0位置的数字保存到临时变量中；
2，把下标0位置的数字跟数组的最后一个数字进行交换，并把heapSize设置为N-1

那么这时，大根堆的最大值就是数组的最后一个位置，并且不在HeapSize所表示大根堆的范围内了

3.再把N-1的数组调整为最大堆（==heapify操作==）

默认为下沉到底，那么下沉的高度就是大根堆的高度，

所以下沉的时间复杂度：logN

```
Code02_Heap01
```

## 堆排序

### 常规的堆排序

1.先形成一个大根堆  O(N*logN)

2.再对大根堆进行排序  O(N*logN)

 第一步+第二步的时间复杂度：O(N*logN)


```
// O(N*logN)
	for (int i = 0; i < arr.length; i++) { // O(N)
		heapInsert(arr, i); // O(logN)
	}
```

### 优化

==对第1步进行优化，形成一个大根堆，有时间复杂度为O(N)的优化==

优化：只是调整为大根堆，不需要有序

从数组最后开始遍历，调整为大根堆

```
//优化
for (int i = arr.length - 1; i >= 0; i--) {
	heapify(arr, i, arr.length);
}
```

2.再对大根堆进行排序 O(N*logN)


### 证明优化方案的时间复杂度更好

现在有一棵完全二叉树，节点有N个

那么最后一层的节点个数：N/2

倒数第二层的节点个数：N/4

依次为N/8   N/16   N/32 ....

现在做heapfiy操作，

最底层的节点，==只看了一眼，不需要往下沉==，那么最底层节点的操作数：N/2 * 1

倒数第二层的节点：==看自己一眼，有可能往下沉==，那么倒数第二层节点的操作数：N/4 * 2

倒数第三层的节点：看自己一眼，就算沉到底，也只是交换两次，那么倒数第三层的节点的操作数：N/8 * 3

所以表达式：T(N)=N/2*1  +  N/4*2  + N/8*3 + N/16*4 +....

2*T(N) = N/2*2  +  N/2*2  + N/4*3 + N/8*4 +....

2*T(N)-T(N)=T(N)= N + N/2 + N/4 + N/8 + ...

等比数列，得到时间复杂度O(N)

图片401.png

如果用户一个一个提供数字，只能用heapInsert操作

如果用户以下提供很多数字，就可以使用heapify操作

通过看代码，发现没有使用递归，就能知道堆排序最大的优势：

==堆排序额外空间复杂度为O(1)==

```
Code04_HeapSort
```

## 堆排序：总结

堆排序

1.先让整个数组都变成大根堆结构，建立堆的过程：
    1).从上到下的方法，时间复杂度为O(N*logN)
    2).从下到上的方法，时间复杂度为O(N)

2.把对的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)

3.堆的大小减小成0之后，排序完成


```
系统实现的堆

Test
```

## 与堆有关的题目

### 已知一个几乎有序的数组，每个元素移动的距离一定不超过k

已知一个几乎有序的数组。几句有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

请选择一个合适的排序策略，对这个数组进行排序。

思路：
    
    1.把K+1的数放到小根堆里
        因为移动的距离一定不超过k，所以在原始数组中只有0到k位置的数，才有可能到达下标为0的位置
    2.弹出小根堆里最小值，也就是下标为0的数字
    3.把K+1位置的数放到小根堆里
        因为只有1到K+1位置的数字，才有可能到达下标1的位置
    

时间复杂度：

    因为移动的距离不超过k，说明数组每一个元素移动的距离是O(logK)
    数组有N个元素，那么时间复杂度O(N*logK)
    
```
Code05_SortArrayDistanceLessK
```

# 比较器

1.比较器的实质就是重载比较运算符
2.比较器可以很好的应用在特殊标准的排序上
3.比较器可以很好的应用在根据特殊标准排序的结构上
4.写代码变得异常容易，还用与泛型编程


```
Code01_Comparator
```

# 语言提供的堆结构 VS 手写的堆结构

取决于，你又没偶有动态改信息的需求！

语言提供的堆结构，如果你动态改数据，不保证依然有序

即使语言提供了方法可以调整，时间复杂度也不会太好

C、java语言没有提供这样的方法：

手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求！并且时间复杂度为O(logN)

系统实现的堆 PriorityQueue ，默认为小根堆


---

之前，用户新增一个节点heapinsert成为最大堆；

用户删除一个节点通过heapify成为最大堆；

现在呢，用户想修改已经排好序的堆的值，然后通过resign() 让数组再次有序，并且时间复杂度为O(logN)





```
Code03_Heap02
```
