[TOC]

# 答疑：从上往下建堆和从下往上建堆(更优)的时间复杂度不一样

从上往下建堆：O(N*logN)

从下往上建堆：O(N)---上节课已经证明过

直观理解：

    前面节点少，代价低；后面节点多，代价高
    而从下往上建堆：下面节点多，代价低；上面节点少，代价高

## 证明：从上往下建堆：O(N*logN)

假如有N个节点，从上往下建堆的时间复杂度为O(N)

那么现在有2N个节点，从上往下建堆的时间复杂度也可以收敛到O(N),因为跟常数项没关系

证明：2N个节点，相当于分成两部分N节点去建堆

第一部分N节点，时间复杂度为O(N)

第二部分的N节点，在已经建好的堆（高度为logN）插入的话，时间复杂度：O(N*logN)

所有2N个节点，时间复杂度不可能为O(N)

# trie前缀树

这个知识点跟排序没有关系，是独立的知识点

1.单个字符串中，字符从前到后的加到一颗多叉数上
2.字符放在路上，节点上有专属的数据项（常见的是pass和end值）
3.所有样本都这样添加，如果没有路就新建，如有路就复用
4.沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

可以完成前缀相关的查询

## 题目

现在有一些字符串类型的数组{"abc","adb","kst"},想把所有样本建出一个前缀数

分析过程；

(int) pass：在字符加入的过程中，当前节点通过的次数

(int) end:在加字符的过程中，成为了多少个字符串的结尾

图片501.png

图片502.png

## 前缀树的用途：

所有字符串中的字符数量为N，把整棵树建好的时间复杂度：O(N)

因为每处理一个字符的代价是O(1),不管是新建节点，还是移动

## 问题1：加入的字符串有多少个字符串是以“a”做前缀

pass值--prefixNumber()

## 问题2：加入的字符串有多少个字符串是以“d”做前缀

end值--search()

## 问题3：删除字符串

注意一种情况：如果删除以后，有些节点没有用了；即节点的pass变成0

那么指向null

delete()

图片503.png

## 如果内容不只小写字母，是ASCII码（最多为65535个）,采用hash表

类：Node2

## 前缀数的时间复杂度

时间复杂度取决于要操作的字符串的长度

insert、delete、search、prefixNumber

## 前缀树的拓展

如果一道题跟前缀查询有关，那么就可以使用前缀树

后续会有相关的实战题目

```
Code02_TrieTree
```

## Code1中的bug在哪？

# 不基于比较的排序

桶排序思想下的排序：计数排序 & 基数排序

1.桶排序思想下的排序都是不基于比较的排序

2.时间复杂度O(N),额外空间复杂度O(M)

3.应用范围有限，需要样本的数据状况满足桶的划分

==在刷题或面试中，除非特殊申明，否则你算法流程中有排序步骤的话，你必须按照基于比较的排序进行复杂度的估算==

## 计数排序和基数排序

1.一般来讲，计数排序要求，样本是整数，且范围比较窄

2.一般来讲，基数排序要求，样本是10进制的正整数

一旦要求稍有升级，改写代价增加时显而易见的

## 计数排序

适用于：一个比较窄的数据范围，例如员工年龄，


```
Code03_CountSort
```

## 基数排序

适用范围：不能有负数，并且都是十进制的数

哪位的权重大，放到最后最后排序：所以先个数进桶、依次 十位、百位

**过程理解和代码实现看起来是两回事**

==实际时间复杂度为：O(N*log10^max)，但是一般还是按O(N)来说；max是最大有几位==

```
Code04_RadixSort
```

# 排序算法的稳定性

稳定性是指同样大小的样本在排序之后不会改变相对次序

对基础类型来说，稳定性毫无意义

对非基础类型来说，稳定性有重要意义

有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

举例：有很多学生，属性：班级号、年龄，

第一步：按所有学生所有年龄从小到达排序

第二步：按照班级号从小到大排序

如果有稳定性的话，按班级排序时，每个班的同学年龄从小到大

==举例二：商城价格从小打大，好评度从好到坏，那么首先出现的是：物美价廉的==

选择排序：没有稳定性，因为从0到N-1，随机选一个最小数放到0位置上，这一步就破坏了稳定性，例如55551555，最小数1跟数组0位置的5交换，这一步就破坏了稳定性

冒泡排序：有稳定性，处理相等时的态度，决定了稳定性

插入排序：可以实现稳定性；处理相等时的态度，决定了稳定性

归并排序：如果相等时，先拷贝左边的，那么是稳定的；但是如果在归并排序的基础上做逆序对问题、小和问题，如果相等时，先拷贝右边的，排序功能不会破坏，但是稳定性会破坏

快速排序：没有稳定性，因为Partition过程没有稳定性

堆排序：不稳定，因为只关心生成大根堆、小根堆，不关心是否稳定

# 排序算法总结


header 1 | 时间复杂度| 额外空间复杂度| 稳定性 | 评价
---|---|---|--- | --
选择排序 | O(N^2) | O(1) | 无 | 最差的
冒泡排序 | O(N^2) | O(1) | 有
插入排序 | O(N^2) | O(1) | 有
归并排序 | O(N*logN) | O(N) | 有
随机快排 | O(N*logN | O(logN) | 无
堆排序 | O(N*logN) | O(1) | 无
== | == | == |==
计数排序 | O(N) | O(M) | 有
计数排序 | O(N) | O(N) | 有

图片504.png



---

## 私货总结

### 排序算法总结

1.不基于比较的排序，对样本数据有严格要求，不易改写
2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3.基于比较的排序，时间复杂度的极限是O(N*logN)
4.==时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的==
5.为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

大量的实验发现快排的常数项最小

### 常见的坑

1.归并排序的额外空间复杂度可以变成O(1),"归并排序 内部缓存法"，但是将变得不再稳定

    搜索"归并排序 内部缓存法"，并且很复杂，需要花费一周的时间来研究
    没有意义，既然都不要稳定性了，应该选择快排

2.“原地归并排序”是垃圾帖，会让时间复杂度变成O(N^2)

    “原地归并排序”可以使空间复杂度变成O(1)
    既然时间复杂度都O(N^2)，插排不香吗？

3.快速排序稳定性改进，“01 stable sort”,但是会对样本数据要求更多。

    论文“01 stable sort”
    既然对样本数据有要求，那么为什么不选择桶排序呢？
    
4.在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。要求：时间复杂度做到O(N),额外空间复杂度做到O(1)

    面试官，我理解你说的，在原始数组中，奇数放在左边，偶数放在右边，还要保持相对次序不变，时间复杂度O(N),额外空间复杂度O(1)
    它是一个0、1标准的Partition；
    而快排经典的partition过程是做不到稳定性的
    既然您说可以保证稳定性，那么请教您为什么快排不改成稳定的呢?
    
    他说这种事坑3中的论文“01 stable sort”，对样本数据要求很高，既然是这样的话，为什么不使用桶排序呢？
    
==注意：很多面试官喜欢拿这个来压面试者的身价==
    
# 工程上对排序的改进

1.稳定性的考虑

    Arrays.sort()
    首先会利用反射，查看数据类型，考虑稳定性
    如果是基础类型，会使用快排；
    如果是引用类型，会使用归并排序
    
2.充分利用O(N*logN)和O(N^2)排序各自的优势

    在代码中发现，在快排的process()中，如果L到R不够60个数，采用了插入排序，为什么呢？

    因为归并、快排、堆排的时间复杂度为O(N*logN)，这三种排序是调度有优势，但是常数项很大的，
    而插入排序是调度不好，常数项很低，

    在小样本量的情况下，利用常数项很低的优势，N很小，瓶颈不是很明显
    让方法更优