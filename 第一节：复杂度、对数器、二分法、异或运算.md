[TOC]

# 1.复杂度
## 评估算法优劣的核心指标是什么？

> 时间复杂度（流程决定）
> 
> 额外空间复杂度（流程决定）
> 
> 常数项时间（实现细节决定）


## 时间复杂度
### 何为常数时间的操作？

如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作

### 常见的常数时间操作

> 常见的算术运算（+ - * / %等）
> 
> 常见的位运算（>> >>>  <<  | & ^等）
> ≠
> 赋值、比较、自增、自减操作等
> 
> 数组寻址操作
> 
> 总之，执行时间固定的操作都是常数时间的操作
> 
> 反之，执行时间不固定的操作(LinkedList.get)，都不是常数时间的操作

### 如何确定算法流程的总操作数量与样本数量之间的表达式关系？

> 1.想想该算法流程所处理的数据状况，要按照最差情况来
> 
> 2.把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作
> 
> 3.如果数据量为N，看看基本动作的数量和N是什么关系
    
### 如何确定算法流程的时间复杂度？

当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。记为O(忽略掉系数的高阶项)

### 时间复杂度的意义

抹掉了好多东西，只剩下了一个最高阶项啊

时间复杂度的意义在于：当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。

这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

### 选择排序：看+比较，再加一次交换

    表达式：N*(看+比)+1=N*(2)+1
    (N-1) * (看+比)+1 =(N-1)*(2)+1
    (N-2) * (看+比)+1 =(N-2)*(2)+1
    
    ...
    
    2*(N + N-1 + N-2) +N   等差数列aN² + bN+c
    =2aN²+bN+N+C
    =O(N²)
    
    空间复杂度BG O(1)
    
### 冒泡排序

最大值到最后

时间复杂度：O(N²)

空间复杂度BG O(1)

### 插入排序

时间复杂度：O(N²)

空间复杂度BG O(1)

### 总结

1.算法的过程，和具体的语言是无关的

2.想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉

3.一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉、否则会影响你对时间复杂度的估算。


## 额外空间复杂度

## 常数项时间

我们会发现，时间复杂度这个指标是忽略低阶项和所有常数系数的

难道同样时间复杂度的流程，在实际运行时候就一样的好吗？当然不是

时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去时间上拼优劣，就进入到拼常数项时间的阶段，简称拼常数项

### 算法流程的常数项的比拼方式

放弃理论分析，生成随机数据直接测

为什么不去理论分析？

不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快有慢之分的。

比如位运算的常数时间远小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。

所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了

## 面试、比赛、刷题中，一个问题的最优解是什么意思？

一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。

一般说起最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。

C/C++  只给1秒

java/python/其他语言  给2到4秒

==一般面试是不卡常数项时间的，如果卡了，可以跟面试公司写邮件，说为什么同样的时间复杂度，我被pass了==

## 常见的时间复杂度（我们陆续都会见到的）

    排名从好到差
    O(1)
    O(logN)
    O(N)
    O(N*logN)
    O(N^2)  O(N^3)  ... O(N^k)
    O(2^N)  O(3^N)  ... O(K^N)
    O(N!)

# 算法和数据结构学习的大脉络

1.知道怎么算的算法

2.知道怎么试的算法

    其实就是写递归的能力

我们所有的题目讲解，对于大脉络的实践贯穿始终

# 对数器

你在网上找到了某个公司的面试题，你想了好久，感觉自己会做，但是你找不到在线测试

你和朋友交流面试题，你想了好久，感觉自己会做，但是你找不到在线测试

你在网上做笔试，但是前几个测试用例都过了，突然一个巨大无比数据量来了，结果你的代码报错了，如此大的数据量根本看不出哪错了，

你好心烦。。。

## 认识对数器

1. 你想要测的方法a
2. 实现复杂度不好但是容易实现的方法b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

# 二分法

1.在一个有序数组中，找某个数是否存在

2.在一个有序数组中，找>=某个数最左侧的位置

3.在一个有序数组中，找<=某个数最右侧的位置

4.局部最小值问题

## 认识二分法

经常见到的类型是在一个有序数组上，开展二分搜索

但有序真的是所有问题求解时使用二分的必要条件吗？

只要能正确构建左右两侧的淘汰逻辑，你就可以二分

常见写法：N*2+1  = ( N<<1 ) | 1

## 在一个有序数组中，找某个数是否存在

## 在一个有序数组中，找>=某个数最左侧的位置

## 在一个有序数组中，找<=某个数最右侧的位置

## 局部最小值问题

有一个无序数组，任意两个相邻的数都不相等，求任意一个局部最小值

分析：

    如果下标0，是不是比下标1的值小；如果是，则下标0为局部最小
    
    如果下标N-1,是不是比下标N-2的值小；如果是，则下标N-1为局部最小
    
    如果不满足上面两个条件，中间必有局部最小
    
    二分：中间的位置，
        如果左边比中间位置小，那么左边必有局部最小
        或者右边比中间位置小，那么右边必有局部最小
        
# 认识异或运算

> 异或运算：相同为0，不同为1
> 
> 同或运算：相同为1，不同为0
> 
> 能长时间记住的概念接近0%
> 
> 所以==异或运算就记成 无进位相加==

> 异或运算的性质
> 
> 1.==0^N ==N   N^N==0==
> 
> 2.==异或运算满足交换律和结合律==
> 
> 上面两个性质用无进位相加来理解就非常的容易

## 题目一：如何不用额外变量交换两个数

    a=a^b  
    b=a^b
    a=a^b
    
==两个数值指的内存地址不一样，哪怕值是一样的，运算正确==

==如果两个数组指的内存地址一样的，结果会变成0==
    
## 题目二：一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

所有这些数异或运算

## 题目三：怎么把一个int类型的数，提取出最右侧的1来

    int n -> 二进制：0..011010100
    
    结果变成0...000010000
    
    与运算：遇0则0     或运算：遇1则1

==N & ((~N)+1) =N 与 (N取反+1)==

用处:题目四

## 题目四：一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

    数组中的所有数异或 得到eor = a^b(肯定不为0，因为这两种数出现了奇数次)
    
    eor & (~eor+1) 提取出最右的1(例如最右是第八位=1)
    
    这时数组可以分为，第八位=1 和第八位不等于1 两部分
    
    第八位等于1的数 & 提取出来的数  != 0
    第八位不等于1的数 & 提取出来的数  = 0
    
    那么第八位等于1的数，进行异或操作，等到其中一个数（出现奇数次） = eor`(例如是a)
    
    那么b = ero ^ eor` = a^b ^ a =b
    
## 题目五：一个数N中二进制中1的个数

先提取最右侧为1的数a， N^a=N(这样讲最右侧的1变为了0)

不能使用 N= N-rightone ,因为如果是负数的话，会出现问题

